# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Add a binary dichotomic algorithm (BDA).
#' 
#' Each added binary dichotomic algorithm (BDA) results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_bda}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [start_bda()] for all codons,
#'           [code_start_bda()] for code, [run_bda()] for executing and run the BDAs
#'
#' @param i_1 A unsigend Integer from 1 - [WORD LENGTH]
#' @param i_2 A unsigend Integer from 1 - [WORD LENGTH]
#' @param Q_11 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_12 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_21 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_22 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @return Boolean value. True if the rules parameters are correct
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
add_bda <- function(i_1, i_2, Q_11, Q_12, Q_21, Q_22) {
    .Call('_GCATR_add_bda', PACKAGE = 'GCATR', i_1, i_2, Q_11, Q_12, Q_21, Q_22)
}

#' Start a BDA procedure for a code.
#' 
#' Each added binary dichotomic algorithm (BDA) results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_bda}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [start_bda()] for all codons, [add_bda] add a BDA,
#'           [run_bda()] for executing and run the BDAs
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the procedure has started
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export
code_start_bda <- function(code, length = -1L) {
    .Call('_GCATR_code_start_bda', PACKAGE = 'GCATR', code, length)
}

#' Execute BDA procedure.
#' 
#' This function executes the currently open binary dichotomic algorithm (BDA) procedure. Therefore, you need to start a BDA procedure.
#' You can call \link{code_start_bda} to start a procedure
#' for all codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' @return A List. A binary representation of the Code.
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' add_bda(1, 3, "A", "G", "C", "T")
#' res.binary <- run_bda()
#'
#' @seealso  [start_bda()] for all codons, [add_bda] add a BDA,
#'           [code_start_bda()] for code
#'
#' @export 
run_bda <- function() {
    .Call('_GCATR_run_bda', PACKAGE = 'GCATR')
}

#' The Genetic Codes
#' 
#' \emph{genetic_codes_by_name} returns a list representing a Genetic Code. The list contains two arrays, one array of the codons and one array of the translated amino acids in the same order.
NULL

#' To calculate the average conductance of a translation table
#'
#' This function calculates the average conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the average conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export 
get_average_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the max conductance of a translation table
#'
#' This function calculates the max conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the max conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_max_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the min conductance of a translation table
#'
#' This function calculates the min conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the min conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_min_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the average conductance of a translation table
#'
#' This function calculates the average conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the average conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_average_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' To calculate the max conductance of a translation table
#'
#' This function calculates the max conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the max conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_max_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' To calculate the min conductance of a translation table
#'
#' This function calculates the min conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String, is optional: DNA or RNA
#'
#' @return A Number, the min conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_min_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' The Genetic Codes
#' 
#' \emph{print_all_translation_tables} prints a list of the genetic codes contained by this project. The list includes names and indexes of the codes.
#' 
#' The Standard Code(transl_table=1)\cr
#' The Vertebrate Mitochondrial Code(transl_table=2)\cr
#' The Yeast Mitochondrial Code(transl_table=3)\cr
#' The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code(transl_table=4)\cr
#' The Invertebrate Mitochondrial Code(transl_table=5)\cr
#' The Ciliate, Dasycladacean and Hexamita Nuclear Code(transl_table=6)\cr
#' The Echinoderm and Flatworm Mitochondrial Code(transl_table=9)\cr
#' The Euplotid Nuclear Code(transl_table=10)\cr
#' The Bacterial, Archaeal and Plant Plastid Code(transl_table=11)\cr
#' The Alternative Yeast Nuclear Code(transl_table=12)\cr
#' The Ascidian Mitochondrial Code(transl_table=13)\cr
#' The Alternative Flatworm Mitochondrial Code(transl_table=14)\cr
#' Ter Chlorophycean Mitochondrial Code(transl_table=16)\cr
#' Trematode Mitochondrial Code(transl_table=21)\cr
#' Scenedesmus obliquus Mitochondrial Code(transl_table=22)\cr
#' Thraustochytrium Mitochondrial Code(transl_table=23)\cr
#' Pterobranchia Mitochondrial Code(transl_table=24)\cr
#' Candidate Division SR1 and Gracilibacteria Code(transl_table=25)\cr
#' Pachysolen tannophilus Nuclear Code(transl_table=26)\cr
#' Karyorelict Nuclear(transl_table=27)\cr
#' Condylostoma Nuclear(transl_table=28)\cr
#' Mesodinium Nuclear(transl_table=29)\cr
#' Peritrich Nuclear(transl_table=30)\cr
#' Blastocrithidia Nuclear(transl_table=31)\cr
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#' 
#' @seealso \link{genetic_codes_by_index}, \link{genetic_codes_by_name}
#'
#' @examples
#' print_all_translation_tables()
#' 
#' @export 
print_all_translation_tables <- function() {
    invisible(.Call('_GCATR_print_all_translation_tables', PACKAGE = 'GCATR'))
}

#' The Genetic Codes
#' 
#' \emph{genetic_codes_by_index} returns a list representing a Genetic Code. The list contains two arrays, one array of the codons and one array of the translated amino acids in the same order.
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#' 
#' @param idx the index of a Genetic Code as int. (check \link{print_all_translation_table})
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' @examples
#' (code <- genetic_codes_by_index(1))
#' 
#' @export 
genetic_codes_by_index <- function(idx) {
    .Call('_GCATR_genetic_codes_by_index', PACKAGE = 'GCATR', idx)
}

#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#' 
#' @param name the name of a Genetic Code as string. (check \link{print_all_translation_table})
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' @examples
#' (code <- genetic_codes_by_name("The Yeast Mitochondrial Code"))
#' 
#' @export 
genetic_codes_by_name <- function(name) {
    .Call('_GCATR_genetic_codes_by_name', PACKAGE = 'GCATR', name)
}

#' Factors edges and vertices of an representing C3-graph of a circular code
#'
#' This function factors the set of edges and the set of vertices of an representing graph of a circular code.
#' This sets can be used to construct the graph. To get a graph object use \link{code_factor_c3graph}.\cr
#' The difference to the standard Graph is that the edges of the shifted (circular permutated) Codes
#' of the the origin code are included as undirected edges.\cr
#' The following definition describes a directed graph to an n-nucleotide code.
#' Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X), EU(X) ,E(X)) with set of vertices V (X), a set of undirected edges EU(X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...N3 : N1N2N3...Nn in X, 0 < i < 3\}\cr
#' EU (X) = \{[N2,N3N1] : N1N2N3 in X\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3 in X, 0 < i < 3\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of an C3-graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_gen_c3graph(c("ACG", "CAG"))
#' code_prepare_factor_gen_c3graph("ACGCAG", tuple_length=3)
#' code_prepare_factor_gen_c3graph("ACG CAG")
#'
code_prepare_factor_gen_c3graph <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_gen_c3graph', PACKAGE = 'GCATR', code, tuple_length)
}

#' Factors edges and vertices of an representing graph of a circular code
#' 
#' This function factors the set of edges and the set of vertices of an representing graph of a circular code.
#' This sets can be used to construct the graph. To get a graph object use \link{code_factor_graph}.
#' The following definition describes a directed graph to an n-nucleotide code.
#' Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param show_cycles A bool value. If true the all edges which are part of a cycle are colored red.
#' @param show_longest_path A bool value. If true the all edges part of the longest path are colored blue.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_graph(c("ACG", "CAG"), TRUE, TRUE)
#' code_prepare_factor_graph("ACGCAG", tuple_length=3, show_cycles=TRUE, show_longest_path=TRUE)
#' code_prepare_factor_graph("ACG CAG", TRUE, TRUE)
#' 
code_prepare_factor_graph <- function(code, show_cycles = FALSE, show_longest_path = FALSE, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_graph', PACKAGE = 'GCATR', code, show_cycles, show_longest_path, tuple_length)
}

#' Returns a list, with only the cycles in the graph of a circular code.
#' 
#' This function is based on the represent graph of a circular code (see \link{code_prepare_factor_graph}).
#' The function only returns a list of edges and vertices. To get a graph object use \link{code_factor_cycle}.
#' The function checks if the code is circular. If the code is not circular the functions returns all cycles in the representing graph.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the cycles of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_all_cycle(c("ACG", "CAG"))
#' code_prepare_factor_all_cycle("ACGCAG", tuple_length=3)
#' code_prepare_factor_all_cycle("ACG CAG")
#' 
code_prepare_factor_all_cycle <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_all_cycle', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns a list, with only the longest path(s) in the graph of a circular code.
#'
#' This function is based on the represent graph of a circular code (see \link{code_prepare_factor_graph}).
#' The function only returns a list of edges and vertices. To get a graph object use \link{code_factor_longest_path}.
#' The function checks if the code is circular. If the code is not circular the functions returns the logest paths.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.' @param length if code is a sequence, length is the tuple length of the code.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the longest path of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_longest_path(c("ACG", "CAG"))
#' code_prepare_factor_longest_path("ACGCAG", tuple_length=3)
#' code_prepare_factor_longest_path("ACG CAG")
#' 
code_prepare_factor_longest_path <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_longest_path', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is circular.
#' 
#' This function checks if a code is circular. The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.
#' Circular codes are a block codes. We will call a set of tuples \emph{X} of same length
#' a code if every concatenation of words \emph{w} in \emph{X} written on a circle has only a single decomposition into words from \emph{X}.
#' It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames of RNA.\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' code_check_if_circular("ACGCAG", 3)
#' code_check_if_circular("ACG CAG")
#'
#' @export 
code_check_if_circular <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_circular', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is k-circular.
#'
#' This function checks if a code is k-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' k-circular means:\cr
#' That for each sequence/concatenation of less than k tuples of a code \emph{X} written on a circle, there is only one partition in tuples from the code \emph{X}.
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param k is is integer. k refers to the k-circular property.
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_k_circular(2, c("ACG", "CAG"))
#' code_check_if_k_circular(2, "ACGCAG", 3)
#' code_check_if_k_circular(2, "ACG CAG")
#'
#' @export
code_check_if_k_circular <- function(k, code, length = -1L) {
    .Call('_GCATR_code_check_if_k_circular', PACKAGE = 'GCATR', k, code, length)
}

#' Check if a code is Cn-circular.
#'
#' This function checks if a code is Cn-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Cn-circular means:\cr
#' That all circular permutations of the code (all tuples) are circular codes again.\cr
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#'
#' @return Boolean value. True if the code is Cn-circular.
#' @examples
#' code_check_if_cn_circular(c("ACG", "CAG"))
#' code_check_if_cn_circular("ACGCAG", 3)
#' code_check_if_cn_circular("ACG CAG")
#'
#' @export
code_check_if_cn_circular <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_cn_circular', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is comma free.
#'
#' This function checks if a code is comma free.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Comma free is a more restrictive code of the family of the circular codes:\cr
#' A comma-free code is block code in which no concatenation of two code words contains a valid code word that overlaps both.\cr
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is comma free.
#' @examples
#' code_check_if_comma_free(c("ACG", "CAG"))
#' code_check_if_comma_free("ACGCAG", 3)
#' code_check_if_comma_free("ACG CAG")
#'
#' @export
code_check_if_comma_free <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_comma_free', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is self complementary.
#' 
#' This function checks if a code is self complementary.
#' The code can either be a vector of DNA/RNA tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' A code is self complementary if and only if for all tuples in the code the anti-tuple is also in the code.
#' An anti-tuple is te reversed tuple of complementary bases.\cr A <-> T (U) and C <-> G. The anti-tuple of ACG is CGT
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It has to be a RNA/DNA - code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is self-complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' code_check_if_self_complementary("ACGCAG", 3)
#' code_check_if_self_complementary("ACG CAG")
#'
#' @export
code_check_if_self_complementary <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_self_complementary', PACKAGE = 'GCATR', code, length)
}

#' Get acid type of a code
#' 
#' Returns either RNA or DNA depending on the codes Bases. If the code contains only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' the functions returns DNA. If the code contains THYMINE (T) it will also return DNA. On the other side, if the
#' the code contains URACIL (U) bases the function returns RNA. If the code contains URACIL (U) and THYMINE (T) or any other letter
#' then CYTOSINE (C), ADENINE (A), GUANINE (G), URACIL (U) or THYMINE (T) it will return NONE
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It should be a RNA/DNA - code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return String value. One of NONE, DNA, RNA
#' @examples
#' code_get_acid(c("ACG", "CAG"))
#' code_get_acid("ACGCAG", 3)
#' code_get_acid("ACG CAG")
#' 
#' @export
code_get_acid <- function(code, length = -1L) {
    .Call('_GCATR_code_get_acid', PACKAGE = 'GCATR', code, length)
}

#' Finds one longest path in the graph of the code.
#'
#' Prepares a R path string vector. Extracts all longest paths of the Graph G(X) and returns the tuples of the first found one.
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a vector with one longest path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_longest_path} for a graph of the longest path. \link{code_get_all_longest_path_as_vector} for the results as list
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#'
#' @return A String vector. Nodes of the longest path
#' @examples
#' l_path <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#' l_path <- code_get_one_circle_as_vector("ACGCGA", 3)
#' l_path <- code_get_one_circle_as_vector("ACG CGA")
#'
#' @export
code_get_one_longest_path_as_vector <- function(code, length = -1L) {
    .Call('_GCATR_code_get_one_longest_path_as_vector', PACKAGE = 'GCATR', code, length)
}

#' Finds all longest paths in the graph of the code.
#'
#' Prepares a list of R path string vector. Extracts all longest paths of the Graph G(X) and returns a list.
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a list of vector with all longest paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_longest_path} for a graph of the longest path. \link{code_get_all_longest_path_as_vector} for only one result
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#'
#' @return A list of String vectors. Nodes of the longest path
#' @examples
#' l_path <- code_get_all_longest_path_as_vector(c("ACG", "CGA"))
#' l_path <- code_get_all_longest_path_as_vector("ACGCGA", 3)
#' l_path <- code_get_all_longest_path_as_vector("ACG CGA")
#'
#' @export
code_get_all_longest_path_as_vector <- function(code, length = -1L) {
    .Call('_GCATR_code_get_all_longest_path_as_vector', PACKAGE = 'GCATR', code, length)
}

#' Finds one circular sequences constructable in a code.
#'
#' Prepares a R path string vector. Extracts all cycles in the Graph G(X).
#' If the graph has no cycles the vector will be empty. Otherwise it returns a vector with the nodes of
#' a circular path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_cycles} for a graph of the cycles, \link{code_get_all_cycles_as_vector} for the results as list
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List of nodes representing a circular path in G(X).
#'
#' @examples
#' l_graph <- code_get_one_cycles_as_vector(c("ACG", "CGA"))
#' l_graph <- code_get_one_cycles_as_vector("ACGCGA", 3)
#' l_graph <- code_get_one_cycles_as_vector("ACG CGA")
#'
#' @export
code_get_one_cycles_as_vector <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_get_one_cycles_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Finds all circular sequences constructable in a code.
#'
#' Prepares a list of R path string vector. Extracts all cycles in the Graph G(X).
#' If the graph has no cycles the vector will be empty. Otherwise it returns a list of vectors with the nodes of
#' the circular paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_cycles} for a graph of the cycles, \link{code_get_one_cycles_as_vector} for the one result
#'
#' @param  code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List of nodes representing a circular path in G(X).
#'
#' @examples
#' l_graph <- code_get_one_cycles_as_vector(c("ACG", "CGA"))
#' l_graph <- code_get_one_cycles_as_vector("ACGCGA", 3)
#' l_graph <- code_get_one_cycles_as_vector("ACG CGA")
#'
#' @export
code_get_all_cycles_as_vector <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_get_all_cycles_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns all DNA bases
#'
#' @return {"T", "C", "A", "G"}
#'
#' @examples
#' res <- get_dna_bases ()
#'
#' @export 
get_dna_bases <- function() {
    .Call('_GCATR_get_dna_bases', PACKAGE = 'GCATR')
}

#' Returns all RNA bases
#'
#' @return {"U", "C", "A", "G"}
#'
#' @examples
#' res <- get_rna_bases()
#'
#' @export
get_rna_bases <- function() {
    .Call('_GCATR_get_rna_bases', PACKAGE = 'GCATR')
}

#' Analysis a sequence based on a generic code.
#'
#' Finds all appearances of a code in a sequence. Finds the longest connected motive of words of the code in the sequence.
#' The function also calculates the matching bases of the found words in the sequence.
#'
#' @return Returns a List with all analysing results. The list contains the following:\cr
#' \emph{words} (String vector) all found words of the code in the sequence in the correct order.\cr
#' \emph{idx_list} (Number vector) the first-letter index of all found words of the code in the sequence in the correct order.\cr
#' \emph{rest} (String) all parts of the sequence which are not matching the code.\cr
#' \emph{parts} (String vector) the sequence separated in matching and non matching parts. Odd indexes are matching, even indexes are not matching.\cr
#' \emph{longest_match} (Number) the longest connected matching sequence.\cr
#' \emph{total_match_in_percent} (Number) the percentage of the matching parts.
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' seq <- "ACGTCGCGACGTACGACGTCGTACTCGATGCAAGATC"
#' res <- find_and_analysis_code_in_sequence(seq, c("ACG", "TCG"))
#' res <- find_and_analysis_code_in_sequence(seq, "ACGCG", tuple_length=3)
#' res <- find_and_analysis_code_in_sequence(seq, "ACG TCG")
#'
#' @export
find_and_analysis_code_in_sequence <- function(seq, code, tuple_length = -1L) {
    .Call('_GCATR_find_and_analysis_code_in_sequence', PACKAGE = 'GCATR', seq, code, tuple_length)
}

#' This function generates a maximal circular code.
#'
#' Based on a value function each word can be assigned to a value. The code is a set of the words with the
#' lowest value of each permutation class. This code has be proven to be circular and maximal. This can be done for any alphabet.
#'
#' @param alphabet is a vector of letters.
#' @param tuple_length is the tuple length of the resulting code.
#'
#' @return A maximal circular code as String vector.
#'
#' @examples
#' code <- generate_code_by_min_value(c("A", "C", "G", "T"), 3)
#'
#' @export
generate_code_by_min_value <- function(alphabet, tuple_length) {
    .Call('_GCATR_generate_code_by_min_value', PACKAGE = 'GCATR', alphabet, tuple_length)
}

#' Circular shift of all tuples
#'
#' This functions shifts all tuples in code anticlockwise. In other words, the first character of each tuples gets removed and
#' added to the end of the same tuple. Depending on the parameter \emph{shift} this process is repeated multiple times.
#'
#' @param shifts number of shifts
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return shifted code as String vector
#'
#' @examples
#' shifted_code <- shift_tuples(2, c("ACG", "GAT"))
#' shifted_code <- shift_tuples(2, "ACGGAT", tuple_length=3)
#' shifted_code <- shift_tuples(2, "ACG GAT")
#'
#' @export
shift_tuples <- function(shifts, code, tuple_length = -1L) {
    .Call('_GCATR_shift_tuples', PACKAGE = 'GCATR', shifts, code, tuple_length)
}

