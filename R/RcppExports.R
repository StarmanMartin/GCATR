# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' To calculate the average conductance of a translation table
#'
#' This function calculates the average conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the average conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_average_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the max conductance of a translation table
#'
#' This function calculates the max conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the max conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_max_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the min conductance of a translation table
#'
#' This function calculates the min conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeName a String, the name of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the min conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_min_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' To calculate the average conductance of a translation table
#'
#' This function calculates the average conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the average conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_average_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' To calculate the max conductance of a translation table
#'
#' This function calculates the max conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the max conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_max_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' To calculate the min conductance of a translation table
#'
#' This function calculates the min conductance for a selected genetic translation table.
#' The conductance is a number which reflects the robustness of a genetic translation table.
#' The conductance the ration of the codons translating one amino acid which differ in only one position and the
#' codons translating the same amino acid but differ in more then one position.
#'
#' @param codeIdx a Number, the index of the genetic translation table. (see \link{print_all_translation_tables})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return A Number, the min conductance of a genetic translation table
#'
#' @examples
#' ac = get_average_conductance_of_code("The Standard Code")
#' ac = get_average_conductance_of_code("The Vertebrate Mitochondrial Code", "RNA")
#' @export
get_min_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' The Genetic Codes
#'
#' \emph{print_all_translation_tables} prints a list of the genetic codes contained by this project. The list includes names and indexes of the codes.
#'
#' The Standard Code(transl_table=1)\cr
#' The Vertebrate Mitochondrial Code(transl_table=2)\cr
#' The Yeast Mitochondrial Code(transl_table=3)\cr
#' The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code(transl_table=4)\cr
#' The Invertebrate Mitochondrial Code(transl_table=5)\cr
#' The Ciliate, Dasycladacean and Hexamita Nuclear Code(transl_table=6)\cr
#' The Echinoderm and Flatworm Mitochondrial Code(transl_table=9)\cr
#' The Euplotid Nuclear Code(transl_table=10)\cr
#' The Bacterial, Archaeal and Plant Plastid Code(transl_table=11)\cr
#' The Alternative Yeast Nuclear Code(transl_table=12)\cr
#' The Ascidian Mitochondrial Code(transl_table=13)\cr
#' The Alternative Flatworm Mitochondrial Code(transl_table=14)\cr
#' Ter Chlorophycean Mitochondrial Code(transl_table=16)\cr
#' Trematode Mitochondrial Code(transl_table=21)\cr
#' Scenedesmus obliquus Mitochondrial Code(transl_table=22)\cr
#' Thraustochytrium Mitochondrial Code(transl_table=23)\cr
#' Pterobranchia Mitochondrial Code(transl_table=24)\cr
#' Candidate Division SR1 and Gracilibacteria Code(transl_table=25)\cr
#' Pachysolen tannophilus Nuclear Code(transl_table=26)\cr
#' Karyorelict Nuclear(transl_table=27)\cr
#' Condylostoma Nuclear(transl_table=28)\cr
#' Mesodinium Nuclear(transl_table=29)\cr
#' Peritrich Nuclear(transl_table=30)\cr
#' Blastocrithidia Nuclear(transl_table=31)\cr
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' @seealso \link{genetic_codes_by_index}, \link{genetic_codes_by_name}
#'
#' @examples
#' print_all_translation_tables()
#'
#' @export
print_all_translation_tables <- function() {
    invisible(.Call('_GCATR_print_all_translation_tables', PACKAGE = 'GCATR'))
}

#' The Genetic Codes
#'
#' \emph{genetic_codes_by_index} returns a list representing a Genetic Code. The list contains two arrays, one array of the codons and one array of the translated amino acids in the same order.
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#'
#' @param idx the index of a Genetic Code table as int. (check \link{print_all_translation_table})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' @examples
#' (code <- genetic_codes_by_index(1))
#'
#' @export
genetic_codes_by_index <- function(idx, acid = "DNA") {
    .Call('_GCATR_genetic_codes_by_index', PACKAGE = 'GCATR', idx, acid)
}

#' Is a code translatable?
#'
#' This function checks if a code can be translated into amino acids. Therefore, it simply checks if a translation table which fits the tuple size of the code
#' is in the system.\cr.
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple/word length of the code.
#' 
#' @return Boolean value. True if a fitting translation table exists.
#' 
#' @examples
#' code_is_translatable(c("ACG", "CAG"))
#' code_is_translatable("ACGCAG", 3)
#' code_is_translatable("ACG CAG")
#'
#' @export
code_is_translatable <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_is_translatable', PACKAGE = 'GCATR', code, tuple_length)
}

#' The Genetic Codes
#'
#' \emph{cpp_genetic_codes_as_df_by_index} returns a data.frame table which represents a Genetic Code. The table is 4*16.
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#'
#' @param idx the index of a Genetic Code table as int. (check \link{print_all_translation_table})
#' @param acid a String [optional]: The value must be DNA or RNA
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' @examples
#' (code <- genetic_codes_as_df_by_index(1))
#'
cpp_genetic_codes_as_df_by_index <- function(idx, acid = "RNA") {
    .Call('_GCATR_cpp_genetic_codes_as_df_by_index', PACKAGE = 'GCATR', idx, acid)
}

#' The Genetic Codes
#'
#' \emph{genetic_codes_by_name} returns a list representing a Genetic Code. The list contains two arrays, one array of the codons and one
#' array of the translated amino acids in the same order.\cr
#' Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#'
#' @param name the name of a Genetic Code as string. (check \link{print_all_translation_table})
#' @param acid a String [optional]: The value must be DNA or RNA
#' 
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' 
#' @examples
#' (code <- genetic_codes_by_name("The Yeast Mitochondrial Code"))
#'
#' @export
genetic_codes_by_name <- function(name, acid = "RNA") {
    .Call('_GCATR_genetic_codes_by_name', PACKAGE = 'GCATR', name, acid)
}

#' Sequence, Code analyzer
#' 
#' Returns a table with all words in a sequence. For each word, the table shows how often the word appears in the sequence.
#' 
#' @return Key value map of the words in the sequence
#' 
#' @param a character string a sequence of letters and/or numbers
#' @param tuple_length a number, the length of the block or tuple used 
#' 
#' @examples
#' res <- seq_get_tuple_count("ACGCGAACG", 3)
#' 
#' @export
seq_get_tuple_count <- function(seq, tuple_length = 3L) {
    .Call('_GCATR_seq_get_tuple_count', PACKAGE = 'GCATR', seq, tuple_length)
}

#' Sequence, Code analyzer
#' 
#' Returns a table with all words in a sequence. For each word, the table shows how often the word appears in the sequence.
#' 
#' @return A named list with the listed values:\cr
#' \emph{alphabet} (String) All letters and symbols used.\cr
#' \emph{number_of_tuple} (Number) The number of all words/tuples used.\cr
#' \emph{tuple_count} (Key value map) Key value map of the words in the sequence.\cr
#' 
#' @param a character string a sequence of letters and/or numbers
#' @param tuple_length a number, the length of the block or tuple used 
#' 
#' @examples
#' res <- seq_get_info("ACGCGAACG", 3)
#' 
#' @export
seq_get_info <- function(seq, tuple_length = 3L) {
    .Call('_GCATR_seq_get_info', PACKAGE = 'GCATR', seq, tuple_length)
}

#' Factors edges and vertices of an representing C3-graph of a circular code
#'
#' This function factors the set of edges and the set of vertices of an representing graph of a circular code.
#' This sets can be used to construct the graph. To get a graph object use \link{code_factor_c3graph}.\cr
#' The difference to the standard Graph is that the edges of the shifted (circular permutated) Codes
#' of the the origin code are included as undirected edges.\cr
#' The following definition describes a directed graph to an n-nucleotide code.
#' Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X), EU(X) ,E(X)) with set of vertices V (X), a set of undirected edges EU(X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...N3 : N1N2N3...Nn in X, 0 < i < 3\}\cr
#' EU (X) = \{[N2,N3N1] : N1N2N3 in X\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3 in X, 0 < i < 3\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of an C3-graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_gen_c3graph(c("ACG", "CAG"))
#' code_prepare_factor_gen_c3graph("ACGCAG", tuple_length=3)
#' code_prepare_factor_gen_c3graph("ACG CAG")
#'
code_prepare_factor_gen_c3graph <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_prepare_factor_gen_c3graph', PACKAGE = 'GCATR', code, tuple_length)
}

#' Factors edges and vertices of an representing graph of a circular code
#' 
#' This function factors the set of edges and the set of vertices of an representing graph of a circular code.
#' This sets can be used to construct the graph. To get a graph object use \link{code_factor_graph}.
#' The following definition describes a directed graph to an n-nucleotide code.
#' Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param show_cycles A bool value. If true the all edges which are part of a cycle are colored red.
#' @param show_longest_path A bool value. If true the all edges part of the longest path are colored blue.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_graph(c("ACG", "CAG"), TRUE, TRUE)
#' code_prepare_factor_graph("ACGCAG", tuple_length=3, show_cycles=TRUE, show_longest_path=TRUE)
#' code_prepare_factor_graph("ACG CAG", TRUE, TRUE)
#' 
code_prepare_factor_graph <- function(code, show_cycles = FALSE, show_longest_path = FALSE, tuple_length = -55555L) {
    .Call('_GCATR_code_prepare_factor_graph', PACKAGE = 'GCATR', code, show_cycles, show_longest_path, tuple_length)
}

#' Returns a list, with only the cycles in the graph of a circular code.
#' 
#' This function is based on the represent graph of a circular code (see \link{code_prepare_factor_graph}).
#' The function only returns a list of edges and vertices. To get a graph object use \link{code_factor_cycle}.
#' The function checks if the code is circular. If the code is not circular the functions returns all cycles in the representing graph.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the cycles of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_all_cycle(c("ACG", "CAG"))
#' code_prepare_factor_all_cycle("ACGCAG", tuple_length=3)
#' code_prepare_factor_all_cycle("ACG CAG")
#' 
code_prepare_factor_all_cycle <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_prepare_factor_all_cycle', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns a list, with only the longest path(s) in the graph of a circular code.
#'
#' This function is based on the represent graph of a circular code (see \link{code_prepare_factor_graph}).
#' The function only returns a list of edges and vertices. To get a graph object use \link{code_factor_longest_path}.
#' The function checks if the code is circular. If the code is not circular the functions returns the logest paths.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.' @param length if code is a sequence, length is the tuple length of the code.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the longest path of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_longest_path(c("ACG", "CAG"))
#' code_prepare_factor_longest_path("ACGCAG", tuple_length=3)
#' code_prepare_factor_longest_path("ACG CAG")
#' 
code_prepare_factor_longest_path <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_prepare_factor_longest_path', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is circular.
#' 
#' This function checks if a code is circular. The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.
#' Circular codes are a block codes. We will call a set of tuples \emph{X} of same length
#' a code if every concatenation of words \emph{w} in \emph{X} written on a circle has only a single decomposition into words from \emph{X}.
#' It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames of RNA.\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' code_check_if_circular("ACGCAG", 3)
#' code_check_if_circular("ACG CAG")
#'
#' @export 
code_check_if_circular <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_check_if_circular', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns a code as vector.
#' 
#' Turns a sequence or a single string code into a string vector.
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return StringVector code as vector.
#' @examples
#' code_vec <- code_as_vector("ACGCAG", 3)
#' code_vec <- code_as_vector("ACG CAG")
#'
#' @export 
code_as_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns a code as vector.
#' 
#' Turns a sequence or a single string code into a code (ordered string set).
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return StringVector code as vector.
#' @examples
#' code_vec <- code_as_unique_vector("CAGACGACG", 3)
#' code_vec <- code_as_unique_vector("CAG ACG ACG")
#'
#' @export 
code_as_unique_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_as_unique_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a set is a code.
#'
#' This function checks if a code is a code.\cr
#' Let \emph{Sigma} be a finite alphabet and X a subset of \emph{Sigma}*l for some l in N.\cr
#' - For w in \emph{Sigma}*l , an X-decomposition of w is a tuple (x1 ,... , xt ) in Xt with t in N such that
#' X = x 1 · x 2 · · · x t .
#' - A set X subset of \emph{Sigma}*l  is a code if each word w in X has a single X-decomposition.
#' - For an integer l > 1, an l-letter code is a code contained in .
#' Let X be a subset of \emph{Sigma}*l . X is called a code over Σ ∗ if for all n, m > 0 and x1...xn , x1...xm in X,
#' the condition\cr
#' x1...xn = x1...xm\cr
#' implies\cr
#' n = m and xi = xj for i = 1,..., n\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' code_check_if_circular("ACGCAG", 3)
#' code_check_if_circular("ACG CAG")
#'
#' @export
code_check_if_code <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_check_if_code', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is k-circular.
#'
#' This function checks if a code is k-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' k-circular means:\cr
#' That for each sequence/concatenation of less than k tuples of a code \emph{X} written on a circle, there is only one partition in tuples from the code \emph{X}.
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param k is is integer. k refers to the k-circular property.
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_k_circular(2, c("ACG", "CAG"))
#' code_check_if_k_circular(2, "ACGCAG", 3)
#' code_check_if_k_circular(2, "ACG CAG")
#'
#' @export
code_check_if_k_circular <- function(k, code, tuple_length = -55555L) {
    .Call('_GCATR_code_check_if_k_circular', PACKAGE = 'GCATR', k, code, tuple_length)
}

#' Get k value of a k-circular code.
#'
#' This function get the k value of a code which is k-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' k-circular means:\cr
#' That for each sequence/concatenation of less than k tuples of a code \emph{X} written on a circle, there is only one partition in tuples from the code \emph{X}.
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' 
#' @return k value of a k-circular code.
#' 
#' @examples
#' code_k_value(c("ACG", "CAG"))
#' code_k_value("ACGCAG", 3)
#' code_k_value("ACG CAG")
#'
#' @export
code_k_value <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_k_value', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is Cn-circular.
#'
#' This function checks if a code is Cn-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Cn-circular means:\cr
#' That all circular permutations of the code (all tuples) are circular codes again.\cr
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return Boolean value. True if the code is Cn-circular.
#' @examples
#' code_check_if_cn_circular(c("ACG", "CAG"))
#' code_check_if_cn_circular("ACGCAG", 3)
#' code_check_if_cn_circular("ACG CAG")
#'
#' @export
code_check_if_cn_circular <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_check_if_cn_circular', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is comma free.
#'
#' This function checks if a code is comma free.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Comma free is a more restrictive code of the family of the circular codes:\cr
#' A comma-free code is block code in which no concatenation of two code words contains a valid code word that overlaps both.\cr
#' This is an extended property of the circular codes. Circular codes are a block codes. See \link{code_check_if_circular} for more details.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' 
#' @return Boolean value. True if the code is comma free.
#' 
#' @examples
#' code_check_if_comma_free(c("ACG", "CAG"))
#' code_check_if_comma_free("ACGCAG", 3)
#' code_check_if_comma_free("ACG CAG")
#'
#' @export
code_check_if_comma_free <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_check_if_comma_free', PACKAGE = 'GCATR', code, tuple_length)
}

#' Code strip complements
#' 
#' This function removes one codon of each codon anti-codon pair. (see  \link{code_check_if_self_complementary}) 
#' 
#' @param code is either a string vector or a string. It has to be a RNA/DNA - code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' 
#' @return a string the code reduced to a strongly comma-free code
#' 
#' @export
code_strip_complements <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_strip_complements', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is self complementary.
#' 
#' This function checks if a code is self complementary.
#' The code can either be a vector of DNA/RNA tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' A code is self complementary if and only if for all tuples in the code the anti-tuple is also in the code.
#' An anti-tuple is te reversed tuple of complementary bases.\cr A <-> T (U) and C <-> G. The anti-tuple of ACG is CGT
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It has to be a RNA/DNA - code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @param mute set false to get console output information about not self-complementary tuples.
#' 
#' @return Boolean value. True if the code is self-complementary.
#' 
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' code_check_if_self_complementary("ACGCAG", 3)
#' code_check_if_self_complementary("ACG CAG")
#'
#' @export
code_check_if_self_complementary <- function(code, tuple_length = -55555L, mute = TRUE) {
    .Call('_GCATR_code_check_if_self_complementary', PACKAGE = 'GCATR', code, tuple_length, mute)
}

#' Get acid type of a code
#' 
#' Returns either RNA or DNA depending on the codes Bases. If the code contains only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' the functions returns DNA. If the code contains THYMINE (T) it will also return DNA. On the other side, if the
#' the code contains URACIL (U) bases the function returns RNA. If the code contains URACIL (U) and THYMINE (T) or any other letter
#' then CYTOSINE (C), ADENINE (A), GUANINE (G), URACIL (U) or THYMINE (T) it will return NONE
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It should be a RNA/DNA - code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return String value. One of NONE, DNA, RNA
#' @examples
#' code_get_acid(c("ACG", "CAG"))
#' code_get_acid("ACGCAG", 3)
#' code_get_acid("ACG CAG")
#' 
#' @export
code_get_acid <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_get_acid', PACKAGE = 'GCATR', code, tuple_length)
}

#' Gets all amino acids encoded by a code
#' 
#' Returns the amino acids which are encoded by a codes. It returns a list of amino acids in the same order as the code. The code can contain only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' and THYMINE (T) or URACIL (U) bases. If no other translation table is selecte the function will use the 
#' \emph{standard genetic code}. A different tranlastion table has to be added by index. Therefore, (see \link{print_all_translation_tables})\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It should be a RNA/DNA - code or a sequence.
#' @param idx_trans_table the index of a Genetic Code translation table as int. (see \link{print_all_translation_table})
#' 
#' @return String vector. list of amino acids
#' 
#' @examples
#' code_get_all_amino_acids(c("ACG", "CAG"), idx_trans_table=2)
#' code_get_all_amino_acids("ACGCAG", idx_trans_table=2)
#' code_get_all_amino_acids("ACG CAG", idx_trans_table=2)
#' 
#' @export
code_get_all_amino_acids <- function(code, idx_trans_table = 1L) {
    .Call('_GCATR_code_get_all_amino_acids', PACKAGE = 'GCATR', code, idx_trans_table)
}

#' Get amino acids encoded by a code
#' 
#' Returns a set of all the amino acids which are encoded by the codes. The code can contain only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' and THYMINE (T) or URACIL (U) bases. If no other translation table is selecte the function will use the 
#' \emph{standard genetic code}. A different tranlastion table has to be added by index. Therefore, (see \link{print_all_translation_tables})\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It should be a RNA/DNA - code or a sequence.
#' @param idx_trans_table the index of a Genetic Code table as int. (check \link{print_all_translation_table})
#' 
#' @return String vector. list of amino acids
#' 
#' @examples
#' code_get_amino_acids(c("ACG", "CAG"), idx_trans_table=2)
#' code_get_amino_acids("ACGCAG", idx_trans_table=2)
#' code_get_amino_acids("ACG CAG", idx_trans_table=2)
#' 
#' @export
code_get_amino_acids <- function(code, idx_trans_table = 1L) {
    .Call('_GCATR_code_get_amino_acids', PACKAGE = 'GCATR', code, idx_trans_table)
}

#' Finds one longest path in the graph of the code.
#'
#' Prepares a R path string vector. Extracts all longest paths of the Graph G(X) and returns the tuples of the first found one.
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a vector with one longest path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_longest_path} for a graph of the longest path. \link{code_get_all_longest_path_as_vector} for the results as list
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return A String vector. Nodes of the longest path
#' @examples
#' l_path <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#' l_path <- code_get_one_circle_as_vector("ACGCGA", 3)
#' l_path <- code_get_one_circle_as_vector("ACG CGA")
#'
#' @export
code_get_one_longest_path_as_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_get_one_longest_path_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Finds all longest paths in the graph of the code.
#'
#' Prepares a list of R path string vector. Extracts all longest paths of the Graph G(X) and returns a list.
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a list of vector with all longest paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_longest_path} for a graph of the longest path. \link{code_get_all_longest_path_as_vector} for only one result
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return A list of String vectors. Nodes of the longest path
#' @examples
#' l_path <- code_get_all_longest_path_as_vector(c("ACG", "CGA"))
#' l_path <- code_get_all_longest_path_as_vector("ACGCGA", 3)
#' l_path <- code_get_all_longest_path_as_vector("ACG CGA")
#'
#' @export
code_get_all_longest_path_as_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_get_all_longest_path_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Finds one circular sequences constructable in a code.
#'
#' Prepares a R path string vector. Extracts all cycles in the Graph G(X).
#' If the graph has no cycles the vector will be empty. Otherwise it returns a vector with the nodes of
#' a circular path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_cycles} for a graph of the cycles, \link{code_get_all_cycles_as_vector} for the results as list
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List of nodes representing a circular path in G(X).
#'
#' @examples
#' l_graph <- code_get_one_cycles_as_vector(c("ACG", "CGA"))
#' l_graph <- code_get_one_cycles_as_vector("ACGCGA", 3)
#' l_graph <- code_get_one_cycles_as_vector("ACG CGA")
#'
#' @export
code_get_one_cycles_as_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_get_one_cycles_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Finds all circular sequences constructable in a code.
#'
#' Prepares a list of R path string vector. Extracts all cycles in the Graph G(X).
#' If the graph has no cycles the vector will be empty. Otherwise it returns a list of vectors with the nodes of
#' the circular paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso \link{code_factor_cycles} for a graph of the cycles, \link{code_get_one_cycles_as_vector} for the one result
#'
#' @param  code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List of nodes representing a circular path in G(X).
#'
#' @examples
#' l_graph <- code_get_one_cycles_as_vector(c("ACG", "CGA"))
#' l_graph <- code_get_one_cycles_as_vector("ACGCGA", 3)
#' l_graph <- code_get_one_cycles_as_vector("ACG CGA")
#'
#' @export
code_get_all_cycles_as_vector <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_get_all_cycles_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns all DNA bases
#'
#' @return {"T", "C", "A", "G"}
#'
#' @examples
#' res <- get_dna_bases ()
#'
#' @export 
get_dna_bases <- function() {
    .Call('_GCATR_get_dna_bases', PACKAGE = 'GCATR')
}

#' Returns all RNA bases
#'
#' @return {"U", "C", "A", "G"}
#'
#' @examples
#' res <- get_rna_bases()
#'
#' @export
get_rna_bases <- function() {
    .Call('_GCATR_get_rna_bases', PACKAGE = 'GCATR')
}

#' Analysis a sequence based on a generic code.
#'
#' Finds all appearances of a code in a sequence. Finds the longest connected motive of words of the code in the sequence.
#' The function also calculates the matching bases of the found words in the sequence.
#'
#' @return Returns a List with all analysing results. The list contains the following:\cr
#' \emph{words} (String vector) all found words of the code in the sequence in the correct order.\cr
#' \emph{idx_list} (Number vector) the first-letter index of all found words of the code in the sequence in the correct order.\cr
#' \emph{rest} (String) all parts of the sequence which are not matching the code.\cr
#' \emph{parts} (String vector) the sequence separated in matching and non matching parts. Odd indexes are matching, even indexes are not matching.\cr
#' \emph{longest_match} (Number) the longest connected matching sequence.\cr
#' \emph{total_match_in_percent} (Number) the percentage of the matching parts.\cr
#' \emph{circularPermutations} (Number vector) list the circular per
#' 
#' @param seq a character string a sequence of letters and/or numbers
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' seq <- "ACGTCGCGACGTACGACGTCGTACTCGATGCAAGATC"
#' res <- find_and_analysis_code_in_sequence(seq, c("ACG", "TCG"))
#' res <- find_and_analysis_code_in_sequence(seq, "ACGCG", tuple_length=3)
#' res <- find_and_analysis_code_in_sequence(seq, "ACG TCG")
#'
#' @export
find_and_analysis_code_in_sequence <- function(seq, code, tuple_length = -55555L, frame = 0L) {
    .Call('_GCATR_find_and_analysis_code_in_sequence', PACKAGE = 'GCATR', seq, code, tuple_length, frame)
}

#' This function generates a maximal circular code.
#'
#' Based on a value function each word can be assigned to a value. The code is a set of the words with the
#' lowest value of each permutation class. This code has be proven to be circular and maximal. This can be done for any alphabet.
#'
#' @param alphabet is a vector of letters.
#' @param tuple_length is the tuple length of the resulting code.
#'
#' @return A maximal circular code as String vector.
#'
#' @examples
#' code <- generate_code_by_min_value(c("A", "C", "G", "T"), 3)
#'
#' @export
generate_code_by_min_value <- function(alphabet, tuple_length) {
    .Call('_GCATR_generate_code_by_min_value', PACKAGE = 'GCATR', alphabet, tuple_length)
}

#' Circular shift of all tuples
#'
#' This functions shifts all tuples in code anticlockwise. In other words, the first character of each tuples gets removed and
#' added to the end of the same tuple. Depending on the parameter \emph{shift} this process is repeated multiple times.
#'
#' @param shifts number of shifts
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return shifted code as String vector
#'
#' @examples
#' shifted_code <- shift_tuples(2, c("ACG", "GAT"))
#' shifted_code <- shift_tuples(2, "ACGGAT", tuple_length=3)
#' shifted_code <- shift_tuples(2, "ACG GAT")
#'
#' @export
shift_tuples <- function(shifts, code, tuple_length = -55555L) {
    .Call('_GCATR_shift_tuples', PACKAGE = 'GCATR', shifts, code, tuple_length)
}

#' Transformation of all tuples
#'
#' This function transforms all tuples in code. The single letters get transformed by the rules which are set as parameter.
#' The rules are defined as two strings, the \emph{from} and the \emph{to} parameter. These two parameters have to be
#' strings of the same length. Each letter in the \emph{from} string gets transformed to the corresponding letter at the same
#' position of the \emph{to} parameter.
#'
#'
#' @param from the origin letters which are maped to the letters of the \emph{to} parameter.
#' @param to the transformation target letters which are maped letters of to the \emph{from} parameter.
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return transformed code as String vector
#'
#' @examples
#' transformed_tuples <- code_transform_tuples("ACTG", "CAGT", c("ACG", "GAT"))
#' transformed_tuples <- code_transform_tuples("ACTG", "CAGT", "ACGGAT", tuple_length=3)
#' transformed_tuples <- code_transform_tuples("ACTG", "CAGT", "ACG GAT")
#'
#' @export
code_transform_tuples <- function(from, to, code, tuple_length = -55555L) {
    .Call('_GCATR_code_transform_tuples', PACKAGE = 'GCATR', from, to, code, tuple_length)
}

#' Transformation of all tuples
#'
#' This function transforms all tuples in code. The single letters get transformed by the rules which are set as parameter.
#' The rules are the predefined and listed below. This only works for genetic gen codes and sequences\cr
#'
#' SW = (A, T,C,G) -> (T, A, G,C)\cr
#' YR = (A, T,C,G) -> (G,C, T,A)\cr
#' KM = (A, T,C,G) -> (C, G, A, T)\cr
#' AT = (A, T,C,G) -> (T, A,C,G)\cr
#' CG = (A, T,C,G) -> (A, T, G,C)\cr
#' ACTG = (A, T,C,G) -> (C, G, T,A)\cr
#' AGTC = (A, T,C,G) -> (G,C, A, T)\cr
#'
#' @param trans_name tname of a transformation. listed in description.
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return transformed code as String vector
#'
#' @examples
#' transformed_tuples <- code_named_transform_tuples("I", c("ACG", "GAT"))
#' transformed_tuples <- code_named_transform_tuples("SW", "ACGGAT", tuple_length=3)
#' transformed_tuples <- code_named_transform_tuples("SW", "ACG GAT")
#'
#' @export
code_named_transform_tuples <- function(trans_name, code, tuple_length = -55555L) {
    .Call('_GCATR_code_named_transform_tuples', PACKAGE = 'GCATR', trans_name, code, tuple_length)
}

#' Tessera check function
#'
#' This function checks if all words in the code are correct Tessera words.
#' 
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#'
#' @return if code only contains tessera
#'
#' @examples
#' is_tessera <- code_check_if_tessera(c("ACGT", "GATC"))
#' is_tessera <- code_check_if_tessera("ACGTGATC" )
#' is_tessera <- code_check_if_tessera("ACGT GATC")
#' 
#' @export
code_check_if_tessera <- function(code) {
    .Call('_GCATR_code_check_if_tessera', PACKAGE = 'GCATR', code)
}

#' Tessera from codons
#'
#' This function uses a transformation to map all codons to a tessera. This transformation was published by Gonzalez, Giannerini and Rosa. 
#' 
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#'
#' @return the argument code transfomed to a set of tesserae  
#'
#' @examples
#' tessera <- codons_to_tessera(c("ACG", "GAT"))
#' tessera <- codons_to_tessera("ACGGAT")
#' tessera <- codons_to_tessera("ACG GAT")
#' 
#' @export
codons_to_tessera <- function(code) {
    .Call('_GCATR_codons_to_tessera', PACKAGE = 'GCATR', code)
}

#' Codons from Tessera
#'
#' This function uses a transformation to map all tessera to a codon. This transformation was published by Gonzalez, Giannerini and Rosa. 
#' 
#' @param code is either a  tessera string vector or a string. It can either be a code or a sequence.
#'
#' @return the argument code transfomed to a set of codons  
#'
#' @examples
#' codons <- tessera_to_codons(c("ACGT", "GATC"))
#' codons <- tessera_to_codons("ACGT GATC")
#' 
#' @export
tessera_to_codons <- function(code) {
    .Call('_GCATR_tessera_to_codons', PACKAGE = 'GCATR', code)
}

#' Pathend vertices miner
#'
#' This function finds all vertices which have no outgoing edges in the associated graph. 
#' 
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return list of vertices
#'
#' @examples
#' vertices <- code_path_end_vertices_miner(c("ACG", "GAT"))
#' vertices <- code_path_end_vertices_miner("ACGGAT", tuple_length=3)
#' vertices <- code_path_end_vertices_miner("ACG GAT")
#' 
#' @export
code_path_end_vertices_miner <- function(code, tuple_length = -55555L) {
    .Call('_GCATR_code_path_end_vertices_miner', PACKAGE = 'GCATR', code, tuple_length)
}

#' Block length
#'
#' This function gets the block length of a code. 
#' 
#' @param code is either a string vector or a string. It has to be a set of words/blocks
#'
#' @return block length
#'
#' @examples
#' block.length <- code_block_length(c("ACG", "GAT"))
#' block.length <- code_block_length("ACG GAT")
#' 
#' @export
code_block_length <- function(code) {
    .Call('_GCATR_code_block_length', PACKAGE = 'GCATR', code)
}

#' Tables associated to Tessera
#'
#' This function generates a table that represents a Tessera code. The exact definition can be found in the article: "Circular Tessera Codes in the Evolution of the Genetic Code". 
#' 
#' @param code is either a  tessera string vector or a string. It can either be a code or a sequence.
#'
#' @return A 4*4 tabele associated to the Tessera code
#'
#' @examples
#' table <- tessera_to_table(c("ACGT", "GATC"))
#' table <- tessera_to_table("ACGT GATC")
#' 
#' @export
tessera_to_table <- function(code) {
    .Call('_GCATR_tessera_to_table', PACKAGE = 'GCATR', code)
}

#' Tables associated to Tessera as String
#'
#' This function generates a table that represents a Tessera code. The exact definition can be found in the article: "Circular Tessera Codes in the Evolution of the Genetic Code". 
#' 
#' @param code is either a  tessera string vector or a string. It can either be a code or a sequence.
#'
#' @return A 4*4 tabele associated to the Tessera code as String
#'
#' @examples
#' table <- tessera_to_table_str(c("ACGT", "GATC"))
#' table <- tessera_to_table_str("ACGT GATC")
#' 
#' @export
tessera_to_table_str <- function(code) {
    .Call('_GCATR_tessera_to_table_str', PACKAGE = 'GCATR', code)
}

