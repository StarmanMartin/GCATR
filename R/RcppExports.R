# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Add a binary dichotomic algorithm (BDA).
#' 
#' Each added BDA results one binary digit for each codon. You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all RNA codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons,
#'           [code_start_bda()] for code, [run_bda()] for executing and run the BDAs
#'
#' @param i_1 A unsigend Integer from 1 - [WORD LENGTH]
#' @param i_2 A unsigend Integer from 1 - [WORD LENGTH]
#' @param Q_11 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_12 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_21 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_22 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @return Boolean value. True if the rules parameters are correct
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
add_bda <- function(i_1, i_2, Q_11, Q_12, Q_21, Q_22) {
    .Call('_GCATR_add_bda', PACKAGE = 'GCATR', i_1, i_2, Q_11, Q_12, Q_21, Q_22)
}

#' Start a BDA procedure for a code.
#' 
#' To generate a BDA based binary representation of a code or a list of codons, you need to start a BDA procedure. 
#' To do so you can eihter call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [run_bda()] for executing and run the BDAs
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the procedure has started
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export
code_start_bda <- function(code) {
    .Call('_GCATR_code_start_bda', PACKAGE = 'GCATR', code)
}

#' Start a BDA procedure for a sequence.
#' 
#' To generate a BDA based binary representation of a code or a list of codons, you need to start a BDA procedure. 
#' To do so you can eihter call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [code_start_bda()] for code, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [run_bda] for executing and run the BDAs
#'
#' @param seq A gene sequence as string.
#' @param word_length A number, the length of the codons in the seq.
#' @return Boolean value. True if the procedure has started
#' @examples
#' seq_start_bda("ACGCAG", 3)
#' add_bda(1, 2, "C", "G", "A", "T")
#' add_bda(1, 3, "A", "G", "C", "T")
#' res <- run_bda()
#' 
#' @export 
seq_start_bda <- function(seq, word_length) {
    .Call('_GCATR_seq_start_bda', PACKAGE = 'GCATR', seq, word_length)
}

#' Execute BDA procedure.
#' 
#' Run the currently open BDA procedure. Therefore, you need to start a BDA procedure. 
#' You can call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}} for a code. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' @return A List. A binary representation of the Code.
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' add_bda(1, 3, "A", "G", "C", "T")
#' res.binary <- run_bda()
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [code_start_bda()] for code
#'
#' @export 
run_bda <- function() {
    .Call('_GCATR_run_bda', PACKAGE = 'GCATR')
}

#' @export 
get_average_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_max_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_min_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_average_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' @export 
get_max_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' @export 
get_min_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' @export 
print_all_translation_table <- function() {
    invisible(.Call('_GCATR_print_all_translation_table', PACKAGE = 'GCATR'))
}

seq_prepare_factor_gen_c3graph <- function(seq, word_length) {
    .Call('_GCATR_seq_prepare_factor_gen_c3graph', PACKAGE = 'GCATR', seq, word_length)
}

code_prepare_factor_gen_c3graph <- function(code) {
    .Call('_GCATR_code_prepare_factor_gen_c3graph', PACKAGE = 'GCATR', code)
}

#' Get edges of an generic graph
#' 
#' The following definition relates a directed graph to
#' any n-nucleotide code. Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code A vertor with codons.
#' @return List: Edges and vertices of an generic graph. If A -> CG the Letter A is followed by the string CG.
#' @examples
#' code_prepare_factor_gen_graph(c("ACG", "CAG"))
#' 
code_prepare_factor_gen_graph <- function(code, show_circles = FALSE, show_longest_path = FALSE) {
    .Call('_GCATR_code_prepare_factor_gen_graph', PACKAGE = 'GCATR', code, show_circles, show_longest_path)
}

#' Get edges of an generic graph
#' 
#' The following definition relates a directed graph to
#' any n-nucleotide code. Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @return List: Edges and vertices of an generic graph. If A -> CG the Letter A is followed by the string CG.
#' @examples
#' seq_prepare_factor_gen_graph(c("ACG", "CAG"))
#' 
seq_prepare_factor_gen_graph <- function(seq, word_length, show_circles = FALSE, show_longest_path = FALSE) {
    .Call('_GCATR_seq_prepare_factor_gen_graph', PACKAGE = 'GCATR', seq, word_length, show_circles, show_longest_path)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @examples
#' code_prepare_factor_all_circles(c("ACG", "CAG"))
#' 
code_prepare_factor_all_circles <- function(code) {
    .Call('_GCATR_code_prepare_factor_all_circles', PACKAGE = 'GCATR', code)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @examples
#' seq_prepare_factor_all_circles("ACGCAG", 3)
#' 
seq_prepare_factor_all_circles <- function(seq, word_length) {
    .Call('_GCATR_seq_prepare_factor_all_circles', PACKAGE = 'GCATR', seq, word_length)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @examples
#' code_prepare_factor_all_circles(c("ACG", "CAG"))
#' 
code_prepare_factor_longest_path <- function(code) {
    .Call('_GCATR_code_prepare_factor_longest_path', PACKAGE = 'GCATR', code)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @examples
#' seq_prepare_factor_all_circles("ACGCAG", 3)
#' 
seq_prepare_factor_longest_path <- function(seq, word_length) {
    .Call('_GCATR_seq_prepare_factor_longest_path', PACKAGE = 'GCATR', seq, word_length)
}

#' Check if a DNA/RNA code is circular.
#' 
#' This function checks if a genetic code is circular.
#' Circular codes is an approach for finding the method used in gens for retrieving the correct reading frames.\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_circular <- function(code) {
    .Call('_GCATR_code_check_if_circular', PACKAGE = 'GCATR', code)
}

#' Check if a DNA/RNA code is cn circular.
#'
#' This function checks if a genetic code is cn circular.
#' Circular codes is an approach for finding the method used in gens for retrieving the correct reading frames.
#' For a code to be cn circular means that each circular permutation of all codons construct a new circular code.
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the code is cn circular.
#' @examples
#' code_check_if_cn_circular(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_cn_circular <- function(code) {
    .Call('_GCATR_code_check_if_cn_circular', PACKAGE = 'GCATR', code)
}

#' Check if a code is comma free.
#' 
#' The function checks if the code is comma free. 
#' Comma free is a stronger restricted version of the circular code property.
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the code comma free.
#' @examples
#' code_check_if_comma_free(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_comma_free <- function(code) {
    .Call('_GCATR_code_check_if_comma_free', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) in the code the corresponding anti-codons.
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vector with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_self_complementary <- function(code) {
    .Call('_GCATR_code_check_if_self_complementary', PACKAGE = 'GCATR', code)
}

#' Get acid type of a code
#' 
#' Returns either RNA or DNA depending on the codes Bases. If the code contains only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' the functions returns DNA. If the code contains THYMINE (T) it will also return DNA. On the other side, if the
#' the code contains URACIL (U) bases the function returns RNA. If the code contains URACIL (U) & THYMINE (T) or any other letter
#' then CYTOSINE (A), ADENINE (A), GUANINE (G), URACIL (U) or THYMINE (T) it will return NONE
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vector with codons.
#' @return String value. One of NONE, DNA, RNA
#' @examples
#' acid <- code_get_acid(c("ACG", "CAG"))
#' 
#' @export
code_get_acid <- function(code) {
    .Call('_GCATR_code_get_acid', PACKAGE = 'GCATR', code)
}

#' Finds one longest path constructable in a code.
#'
#' Prepares a R path string vector. Extracts all longest paths of the Graph G(X).
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a vector with one longest path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_longest_path(code)] for code, [code_get_all_longest_path_as_vector()] for the results as list
#'
#' @param code A DNA or RNA code as string vector represented by the graph.
#' @examples
#' l_path <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#'
#' @export
code_get_one_longest_path_as_vector <- function(code) {
    .Call('_GCATR_code_get_one_longest_path_as_vector', PACKAGE = 'GCATR', code)
}

#' Finds all longest path constructable in a code.
#'
#' Prepares a List of R path string vector. Extracts all longest path of the Graph G(X).
#' If the graph shows a cycle the list will be empty. Otherwise it returns a list object containing vectors with all
#' longest paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_longest_path(code)] for code, [code_get_one_longest_path_as_vector()] for one result as vector
#'
#' @param code A DNA or RNA code as string vector represented by the graph.
#' @examples
#' l_path_list <- code_get_all_circle_as_vector(c("ACG", "CGA"))
#'
#' @export
code_get_all_longest_path_as_vector <- function(code) {
    .Call('_GCATR_code_get_all_longest_path_as_vector', PACKAGE = 'GCATR', code)
}

#' Finds one circle constructable in a code.
#'
#' Prepares a R path string vector. Extracts all circle path of the Graph G(X).
#' If the graph shows no cycle the vector will be empty. Otherwise it returns a vector with one
#' circle paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_circles(code)] for code, [code_get_all_circle_as_vector()] for the results as list
#'
#' @param code A DNA or RNA code as string vector represented by the graph.
#' @examples
#' l_path <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#'
#' @export
code_get_one_circle_as_vector <- function(code) {
    .Call('_GCATR_code_get_one_circle_as_vector', PACKAGE = 'GCATR', code)
}

#' Finds all circles constructable in a code.
#'
#' Prepares a List of R path string vector. Extracts all circle path of the Graph G(X).
#' If the graph shows no cycle the list will be empty. Otherwise it returns a list object containing vectors with all
#' circle paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_circles(code)] for code, [code_get_one_circle_as_vector()] for one result as vector
#'
#' @param code A DNA or RNA code as string vector represented by the graph.
#' @examples
#' c_path_list <- code_get_all_circle_as_vector(c("ACG", "CGA"))
#'
#' @export
code_get_all_circle_as_vector <- function(code) {
    .Call('_GCATR_code_get_all_circle_as_vector', PACKAGE = 'GCATR', code)
}

#' Returns all DNA bases
#'
#' @return {"T", "C", "A", "G"}
#' @export 
get_dna_bases <- function() {
    .Call('_GCATR_get_dna_bases', PACKAGE = 'GCATR')
}

#' Returns all DNA bases
#'
#' @return {"U", "C", "A", "G"}
#' @export
get_rna_bases <- function() {
    .Call('_GCATR_get_rna_bases', PACKAGE = 'GCATR')
}

#' Analysis a sequence based on a generic code.
#'
#' Finds all appearance of a code ion a sequence. Finds the longest connected matches of words of the code in the sequence.
#' The function also calculates the matching bases of the found words in the sequence.
#'
#' @return Returns a List with all analysing results. The list contains following:\cr
#' \emph{words} all found words of the code in the sequence in the correct order.\cr
#' \emph{idx_list} the first-letter index of all found words of the code in the sequence in the correct order.\cr
#' \emph{rest} all parts of the sequence which are not matching the code.\cr
#' \emph{parts} the sequence separated in matching and non matching parts. Odd indexes are matching, even indexes are not matching.\cr
#' \emph{longest_match} the longest connected matching sequence.\cr
#' \emph{total_match_in_percent} the percentage of the matching parts.
#'
#' @param seq A DNA or RNA sequence.
#' @param code A DNA or RNA code as string vector represented by the graph.
#' @examples
#' code <- c("ACG", "TCG")
#' seq <- "ACGTCGCGACGTACGACGTCGTACTCGATGCAAGATC"
#' res <- find_amd_analysis_code_in_sequence(seq, code)
#'
#' @export
find_amd_analysis_code_in_sequence <- function(seq, code) {
    .Call('_GCATR_find_amd_analysis_code_in_sequence', PACKAGE = 'GCATR', seq, code)
}

