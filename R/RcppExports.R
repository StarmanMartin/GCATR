# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Add a BDA rule.
#' 
#' A BDA rule defines one step of a binary dichotomic algorithm. To add a rule, you need to start a BDA procedure first.
#' Call \code{\link{code_start_bda}} to start a BDA procedure.
#' For more info on BDAs read:
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Strüngmann. On Models of the Genetic Code generated by Binary Dichotomic Algorithms}
#'
#' @param i_1 A unsigend Integer from 1 - [WORD LENGTH]
#' @param i_2 A unsigend Integer from 1 - [WORD LENGTH]
#' @param Q_11 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_12 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_21 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_22 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @return Boolean value. True if the rules parameter are correct
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda_rule(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
add_bda_rule <- function(i_1, i_2, Q_11, Q_12, Q_21, Q_22) {
    .Call('_GCATR_add_bda_rule', PACKAGE = 'GCATR', i_1, i_2, Q_11, Q_12, Q_21, Q_22)
}

#' Start a BDA procedure.
#' 
#' A binary dichotomic algorithm generates a binary representation of a generic code. To add a rule simply Call \code{\link{add_bda_rule}}.
#' For more info on BDAs read:
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic Code generated by Binary Dichotomic Algorithms}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the procedure has started
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda_rule(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
code_start_bda <- function(code) {
    .Call('_GCATR_code_start_bda', PACKAGE = 'GCATR', code)
}

#' Start a BDA procedure.
#' 
#' A binary dichotomic algorithm generates a binary representation of a generic code. To add a rule simply Call \code{\link{add_bda_rule}}.
#' For more info on BDAs read:
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic Code generated by Binary Dichotomic Algorithms}
#'
#' @param seq A gene sequence.
#' @param word_lenth length of the codons.
#' @return Boolean value. True if the procedure has started
#' @examples
#' seq_start_bda("ACGCAG", 3)
#' add_bda_rule(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
seq_start_bda <- function(seq, word_lenth) {
    .Call('_GCATR_seq_start_bda', PACKAGE = 'GCATR', seq, word_lenth)
}

#' Execute BDA procedure.
#' 
#' Run the currently running BDA procedure. Therefore, you need to start a BDA procedure. 
#' You can call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}} to start the procedure for a code. 
#' To add a rule simply Call \code{\link{add_bda_rule}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' @return A StringVector. A binary representation of the Code.
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda_rule(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
run_bda <- function() {
    .Call('_GCATR_run_bda', PACKAGE = 'GCATR')
}

#' Get edges of an generic graph
#' 
#' The following definition relates a directed graph to
#' any n-nucleotide code. Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code A vertor with codons.
#' @return List: Edges and vertices of an generic graph. If A -> CG the Letter A is followed by the string CG.
#' @examples
#' code_get_edges_of_gen_graph(c("ACG", "CAG"))
#' 
#' @export 
code_get_edges_and_vertices_of_gen_graph <- function(code) {
    .Call('_GCATR_code_get_edges_and_vertices_of_gen_graph', PACKAGE = 'GCATR', code)
}

#' Get edges of an generic graph
#' 
#' The following definition relates a directed graph to
#' any n-nucleotide code. Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @return List: Edges and vertices of an generic graph. If A -> CG the Letter A is followed by the string CG.
#' @examples
#' code_get_edges_of_gen_graph(c("ACG", "CAG"))
#' 
#' @export 
seq_get_edges_and_vertices_of_gen_graph <- function(seq, word_length) {
    .Call('_GCATR_seq_get_edges_and_vertices_of_gen_graph', PACKAGE = 'GCATR', seq, word_length)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @examples
#' code_prepare_plot_all_circles(c("ACG", "CAG"))
#' 
code_prepare_plot_all_circles <- function(code) {
    .Call('_GCATR_code_prepare_plot_all_circles', PACKAGE = 'GCATR', code)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @examples
#' seq_prepare_plot_all_circles("ACGCAG", 3)
#' 
seq_prepare_plot_all_circles <- function(seq, word_length) {
    .Call('_GCATR_seq_prepare_plot_all_circles', PACKAGE = 'GCATR', seq, word_length)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @examples
#' code_prepare_plot_all_circles(c("ACG", "CAG"))
#' 
code_prepare_plot_longest_path <- function(code) {
    .Call('_GCATR_code_prepare_plot_longest_path', PACKAGE = 'GCATR', code)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param seq a nucleotide sequence.
#' @param word_length the length of the word.
#' @examples
#' seq_prepare_plot_all_circles("ACGCAG", 3)
#' 
seq_prepare_plot_longest_path <- function(seq, word_length) {
    .Call('_GCATR_seq_prepare_plot_longest_path', PACKAGE = 'GCATR', seq, word_length)
}

#' Check if a code is circular.
#' 
#' This function checks if a genetic code is circular.
#' Circular codes in gens for retrieving the reading frames of genes.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_circular <- function(code) {
    .Call('_GCATR_code_check_if_circular', PACKAGE = 'GCATR', code)
}

#' Check if a code is C_{n} circular.
#' 
#' This function checks the same property as \code{\link{check_if_circular}}. 
#' Yet,  this function checks the property for for all circular permutations of the codons in the code.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code C_{n} circular.
#' @examples
#' code_check_if_cn_circular(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_cn_circular <- function(code) {
    .Call('_GCATR_code_check_if_cn_circular', PACKAGE = 'GCATR', code)
}

#' Check if a code is comma free.
#' 
#' The function checks if the code is comma free. 
#' Comma free is a stronger restricted version of the circular code property.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_comma_free(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_comma_free <- function(code) {
    .Call('_GCATR_code_check_if_comma_free', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) the corresponding anti-codons. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export 
code_check_if_self_complementary <- function(code) {
    .Call('_GCATR_code_check_if_self_complementary', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) the corresponding anti-codons. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export
code_get_acid <- function(code) {
    .Call('_GCATR_code_get_acid', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) the corresponding anti-codons. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export
code_get_one_logest_path_as_vector <- function(code) {
    .Call('_GCATR_code_get_one_logest_path_as_vector', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) the corresponding anti-codons. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export
code_get_all_logest_path_as_vector <- function(code) {
    .Call('_GCATR_code_get_all_logest_path_as_vector', PACKAGE = 'GCATR', code)
}

#' Check if a code is self complementary.
#' 
#' The function checks if the code is self complementary. A self complementary code contains for 
#' any codon (word) the corresponding anti-codons. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return Boolean value. True if the code self complementary.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' 
#' @export
code_get_one_circle_as_vector <- function(code) {
    .Call('_GCATR_code_get_one_circle_as_vector', PACKAGE = 'GCATR', code)
}

#' Returns a list of circles as vectors.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.
#' @return List of string vectors.
#' @examples
#' code_get_all_circle_as_vector(c("ACG", "CAG"))
#' 
#' @export 
code_get_all_circle_as_vector <- function(code) {
    .Call('_GCATR_code_get_all_circle_as_vector', PACKAGE = 'GCATR', code)
}

