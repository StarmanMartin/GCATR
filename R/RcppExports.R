# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Add a binary dichotomic algorithm (BDA).
#' 
#' Each added BDA results one binary digit for each codon. You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all RNA codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons,
#'           [code_start_bda()] for code, [run_bda()] for executing and run the BDAs
#'
#' @param i_1 A unsigend Integer from 1 - [WORD LENGTH]
#' @param i_2 A unsigend Integer from 1 - [WORD LENGTH]
#' @param Q_11 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_12 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_21 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_22 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @return Boolean value. True if the rules parameters are correct
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export 
add_bda <- function(i_1, i_2, Q_11, Q_12, Q_21, Q_22) {
    .Call('_GCATR_add_bda', PACKAGE = 'GCATR', i_1, i_2, Q_11, Q_12, Q_21, Q_22)
}

#' Start a BDA procedure for a code.
#' 
#' To generate a BDA based binary representation of a code or a list of codons, you need to start a BDA procedure. 
#' To do so you can eihter call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [run_bda()] for executing and run the BDAs
#'
#' @param code is a DNA or RNA code as string vector.
#' @return Boolean value. True if the procedure has started
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda()
#' 
#' @export
code_start_bda <- function(code) {
    .Call('_GCATR_code_start_bda', PACKAGE = 'GCATR', code)
}

#' Start a BDA procedure for a sequence.
#' 
#' To generate a BDA based binary representation of a code or a list of codons, you need to start a BDA procedure. 
#' To do so you can eihter call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}}. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [code_start_bda()] for code, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [run_bda] for executing and run the BDAs
#'
#' @param seq A gene sequence as string.
#' @param word_length A number, the length of the codons in the seq.
#' @return Boolean value. True if the procedure has started
#' @examples
#' seq_start_bda("ACGCAG", 3)
#' add_bda(1, 2, "C", "G", "A", "T")
#' add_bda(1, 3, "A", "G", "C", "T")
#' res <- run_bda()
#' 
#' @export 
seq_start_bda <- function(seq, word_length) {
    .Call('_GCATR_seq_start_bda', PACKAGE = 'GCATR', seq, word_length)
}

#' Execute BDA procedure.
#' 
#' Run the currently open BDA procedure. Therefore, you need to start a BDA procedure. 
#' You can call \code{\link{code_start_bda}} or \code{\link{seq_start_bda}} for a code. To start a procedure
#' for all codons call \code{\link{start_bda}}.
#' To add a BDA simply Call \code{\link{add_bda}}. To execute the BDAs call \code{\link{run_bda}}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' @return A List. A binary representation of the Code.
#' @examples
#' code_start_bda(c("ACG", "CAG"))
#' add_bda(1, 2, "C", "G", "A", "T")
#' add_bda(1, 3, "A", "G", "C", "T")
#' res.binary <- run_bda()
#'
#' @seealso [seq_start_bda()] for sequence, [start_bda()] for all codons, [add_bda] add a BDA,
#'           [code_start_bda()] for code
#'
#' @export 
run_bda <- function() {
    .Call('_GCATR_run_bda', PACKAGE = 'GCATR')
}

#' @export 
get_average_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_max_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_min_conductance_of_code <- function(codeName, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_code', PACKAGE = 'GCATR', codeName, acid)
}

#' @export 
get_average_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_average_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' @export 
get_max_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_max_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' @export 
get_min_conductance_of_codeidx <- function(codeIdx, acid = "DNA") {
    .Call('_GCATR_get_min_conductance_of_codeidx', PACKAGE = 'GCATR', codeIdx, acid)
}

#' The Genetic Codes
#' 
#' \emph{print_all_translation_table} Prints a list of the genetic codes containt by this project. The list includes names and indexes of the codes.
#' 
#' The Standard Code(transl_table=1)\cr
#' The Vertebrate Mitochondrial Code(transl_table=2)\cr
#' The Yeast Mitochondrial Code(transl_table=3)\cr
#' The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code(transl_table=4)\cr
#' The Invertebrate Mitochondrial Code(transl_table=5)\cr
#' The Ciliate, Dasycladacean and Hexamita Nuclear Code(transl_table=6)\cr
#' The Echinoderm and Flatworm Mitochondrial Code(transl_table=9)\cr
#' The Euplotid Nuclear Code(transl_table=10)\cr
#' The Bacterial, Archaeal and Plant Plastid Code(transl_table=11)\cr
#' The Alternative Yeast Nuclear Code(transl_table=12)\cr
#' The Ascidian Mitochondrial Code(transl_table=13)\cr
#' The Alternative Flatworm Mitochondrial Code(transl_table=14)\cr
#' Ter Chlorophycean Mitochondrial Code(transl_table=16)\cr
#' Trematode Mitochondrial Code(transl_table=21)\cr
#' Scenedesmus obliquus Mitochondrial Code(transl_table=22)\cr
#' Thraustochytrium Mitochondrial Code(transl_table=23)\cr
#' Pterobranchia Mitochondrial Code(transl_table=24)\cr
#' Candidate Division SR1 and Gracilibacteria Code(transl_table=25)\cr
#' Pachysolen tannophilus Nuclear Code(transl_table=26)\cr
#' Karyorelict Nuclear(transl_table=27)\cr
#' Condylostoma Nuclear(transl_table=28)\cr
#' Mesodinium Nuclear(transl_table=29)\cr
#' Peritrich Nuclear(transl_table=30)\cr
#' Blastocrithidia Nuclear(transl_table=31)\cr
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#' 
#' @seealso \link{genetic_codes_by_index}, \link{genetic_codes_by_name}
#' 
#' 
#' @export 
print_all_translation_table <- function() {
    invisible(.Call('_GCATR_print_all_translation_table', PACKAGE = 'GCATR'))
}

#' The Genetic Codes
#' 
#' \emph{genetic_codes_by_index} Returns a list representing a  Genetic Code the list contains an array of the codons and an array of the translated amino acids in the same order.
#' 
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#' 
#' @param idx the index of a Genetic Code as int. (check \link{print_all_translation_table})
#' 
#' @examples
#' (code <- genetic_codes_by_index(1))
#' 
#' @export 
genetic_codes_by_index <- function(idx) {
    .Call('_GCATR_genetic_codes_by_index', PACKAGE = 'GCATR', idx)
}

#' The Genetic Codes
#' 
#' \emph{genetic_codes_by_name} Returns a list representing a  Genetic Code the list contains an array of the codons and an array of the translated amino acids in the same order.
#' 
#' \cr Source:\cr
#' \emph{Compiled by Andrzej (Anjay) Elzanowski and Jim Ostell at National Center for Biotechnology Information (NCBI), Bethesda, Maryland, U.S.A.}\cr
#' \emph{Last update of the Genetic Codes: Nov. 18, 2016}
#' \emph{\link{https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi}}
#'
#' @return Returns a named List with all codons and the translated amino acids:\cr
#' \emph{codons} all codons as strings.\cr
#' \emph{amino_acids} the translated aminop acids in same order.\cr
#' 
#' @param name the name of a Genetic Code as string. (check \link{print_all_translation_table})
#' 
#' @examples
#' (code <- genetic_codes_by_name("The Yeast Mitochondrial Code"))
#' 
#' @export 
genetic_codes_by_name <- function(name) {
    .Call('_GCATR_genetic_codes_by_name', PACKAGE = 'GCATR', name)
}

code_prepare_factor_gen_c3graph <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_gen_c3graph', PACKAGE = 'GCATR', code, tuple_length)
}

#' Get edges and vertices of an generic graph
#' 
#' The following definition relates a directed graph to
#' any n-nucleotide code. Recall from graph theory (Clark and Holton, 1991) that a graph G consists of
#' a finite set of vertices (nodes) V and a finite set of edges E. Here, an edge is a set \{v,w\} of vertices
#' from V . The graph is called oriented if the edges have an orientation, i.e. edges are considered to be
#' ordered pairs [v,w] in this case.\cr
#' Definition 2.1. Let X Bn be an n-nucleotide code (n 2 N). We define a directed graph G(X) =
#' (V (X),E(X)) with set of vertices V (X) and set of edges E(X) as follows:
#' N-NUCLEOTIDE CIRCULAR CODES IN GRAPH THEORY 5\cr
#' V (X) = \{N1...Ni,Ni+1...Nn : N1N2N3...Nn in X, 0 < i < n\}\cr
#' E(X) = \{[N1...Ni,Ni+1...Nn] : N1N2N3...Nn in X, 0 < i < n\}\cr
#' The graph G(X) is called the representing graph of X or the graph associated to X.\cr
#' Basically, the graph G(X) associated to a code X interprets n-nucleotide words from X in (n−1) ways
#' by pairs of i-nucleotides and (n-i)-nucleotides for 0 < i < n.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param show_cycles A bool value. If true the all edges which are part of a cycle are colored red.
#' @param show_longest_path A bool value. If true the all edges part of the longest path are colored blue.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_gen_graph(c("ACG", "CAG"), TRUE, TRUE)
#' code_prepare_factor_gen_graph("ACGCAG", tuple_length=3, show_cycles=TRUE, show_longest_path=TRUE)
#' code_prepare_factor_gen_graph("ACG CAG", TRUE, TRUE)
#' 
code_prepare_factor_gen_graph <- function(code, show_cycles = FALSE, show_longest_path = FALSE, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_gen_graph', PACKAGE = 'GCATR', code, show_cycles, show_longest_path, tuple_length)
}

#' Returns a list, with all cycles in the graph of a circular code.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all cycles in the representing graph.
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the cycles of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_all_cycle(c("ACG", "CAG"))
#' code_prepare_factor_all_cycle("ACGCAG", tuple_length=3)
#' code_prepare_factor_all_cycle("ACG CAG")
#' 
code_prepare_factor_all_cycle <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_all_cycle', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns a list, with the longest path(s) in the graph of a circular code.
#' 
#' The function checks if the code is circular. If the code is not circular the functions returns all circles. 
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code A vertor with codons.' @param length if code is a sequence, length is the tuple length of the code.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List: Edges and vertices of only the longest path of an graph representing a circular code.
#'
#' @examples
#' code_prepare_factor_longest_path(c("ACG", "CAG"))
#' code_prepare_factor_longest_path("ACGCAG", tuple_length=3)
#' code_prepare_factor_longest_path("ACG CAG")
#' 
code_prepare_factor_longest_path <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_prepare_factor_longest_path', PACKAGE = 'GCATR', code, tuple_length)
}

#' Check if a code is circular.
#' 
#' This function checks if a code is circular. The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.
#' Circular codes are a block codes. It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames.\cr
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is circular.
#' @examples
#' code_check_if_circular(c("ACG", "CAG"))
#' code_check_if_circular("ACGCAG", 3)
#' code_check_if_circular("ACG CAG")
#'
#' @export 
code_check_if_circular <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_circular', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is k-circular.
#'
#' This function checks if a code is k-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' k-circular means:\cr
#' that for any sequence of less then k tuples of the code there is only one partition into tuples from the code.\cr
#' Circular codes are a block codes. It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param k is is integer. k refers to the k-circular property.
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_k_circular(2, c("ACG", "CAG"))
#' code_check_if_k_circular(2, "ACGCAG", 3)
#' code_check_if_k_circular(2, "ACG CAG")
#'
#' @export
code_check_if_k_circular <- function(k, code, length = -1L) {
    .Call('_GCATR_code_check_if_k_circular', PACKAGE = 'GCATR', k, code, length)
}

#' Check if a code is Cn-circular.
#'
#' This function checks if a code is Cn-circular.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Cn-circular means:\cr
#' that all circular permutations of the code (all tuples) are circular.\cr
#' Circular codes are a block codes. It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_cn_circular(c("ACG", "CAG"))
#' code_check_if_cn_circular("ACGCAG", 3)
#' code_check_if_cn_circular("ACG CAG")
#'
#' @export
code_check_if_cn_circular <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_cn_circular', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is comma free.
#'
#' This function checks if a code is comma free.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Comma free is a more restrictive code of the family of the circular codes:\cr
#' A comma-free code is block code in which no concatenation of two code words contains a valid code word that overlaps both.\cr
#' Circular codes are a block codes. It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It can either be a code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_comma_free(c("ACG", "CAG"))
#' code_check_if_comma_free("ACGCAG", 3)
#' code_check_if_comma_free("ACG CAG")
#'
#' @export
code_check_if_comma_free <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_comma_free', PACKAGE = 'GCATR', code, length)
}

#' Check if a code is self complementary.
#' 
#' This function checks if a code is comma free.
#' The code can either be a vector of tuples or a sequence. If the code
#' is a sequence an additional word length parameter is needed.\cr
#' Comma free is a more restrictive code of the family of the circular codes:\cr
#' A comma-free code is block code in which no concatenation of two code words contains a valid code word that overlaps both.\cr
#' Circular codes are a block codes. It is used as an unproved approach to explain the
#' method used in gens to retrieving the correct reading frames.\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. It has to be a RNA/DNA - code or a sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the code is k-circular.
#' @examples
#' code_check_if_self_complementary(c("ACG", "CAG"))
#' code_check_if_self_complementary("ACGCAG", 3)
#' code_check_if_self_complementary("ACG CAG")
#'
#' @export
code_check_if_self_complementary <- function(code, length = -1L) {
    .Call('_GCATR_code_check_if_self_complementary', PACKAGE = 'GCATR', code, length)
}

#' Get acid type of a code
#' 
#' Returns either RNA or DNA depending on the codes Bases. If the code contains only CYTOSINE (C), ADENINE (A), GUANINE (G)
#' the functions returns DNA. If the code contains THYMINE (T) it will also return DNA. On the other side, if the
#' the code contains URACIL (U) bases the function returns RNA. If the code contains URACIL (U) & THYMINE (T) or any other letter
#' then CYTOSINE (A), ADENINE (A), GUANINE (G), URACIL (U) or THYMINE (T) it will return NONE
#' For more info on this subject read:\cr
#' \link{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492142/},\cr
#' \link{http://dpt-info.u-strasbg.fr/~c.michel/Circular_Codes.pdf},\cr
#' \emph{2007 Christian MICHEL. CIRCULAR CODES IN GENES}
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#' @return String value. One of NONE, DNA, RNA
#' @examples
#' code_get_acid(c("ACG", "CAG"))
#' code_get_acid("ACGCAG", 3)
#' code_get_acid("ACG CAG")
#' 
#' @export
code_get_acid <- function(code, length = -1L) {
    .Call('_GCATR_code_get_acid', PACKAGE = 'GCATR', code, length)
}

#' Finds one longest path constructable in a code.
#'
#' Prepares a R path string vector. Extracts all longest paths of the Graph G(X).
#' If the graph shows a cycle the vector will be empty. Otherwise it returns a vector with one longest path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_longest_path(code)] for code, [code_get_all_longest_path_as_vector()] for the results as list
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' l_path <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#' l_path <- code_get_one_circle_as_vector("ACGCGA", 3)
#' l_path <- code_get_one_circle_as_vector("ACG CGA")
#'
#' @export
code_get_one_longest_path_as_vector <- function(code, length = -1L) {
    .Call('_GCATR_code_get_one_longest_path_as_vector', PACKAGE = 'GCATR', code, length)
}

#' Finds all longest path constructable in a code.
#'
#' Prepares a List of R path string vector. Extracts all longest path of the Graph G(X).
#' If the graph shows a cycle the list will be empty. Otherwise it returns a list object containing vectors with all
#' longest paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_longest_path(code)] for code, [code_get_one_longest_path_as_vector()] for one result as vector
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' l_path_list <- code_get_all_longest_path_as_vector(c("ACG", "CGA"))
#' l_path_list <- code_get_all_longest_path_as_vector("ACGCGA", 3)
#' l_path_list <- code_get_all_longest_path_as_vector("ACG CGA")
#'
#' @export
code_get_all_longest_path_as_vector <- function(code, length = -1L) {
    .Call('_GCATR_code_get_all_longest_path_as_vector', PACKAGE = 'GCATR', code, length)
}

#' Finds one circular sequences constructable in a code.
#'
#' Prepares a R path string vector. Extracts all circular paths of the Graph G(X).
#' If the graph shows no cycles the vector will be empty. Otherwise it returns a vector with one
#' circular path.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_circles(code)] for code, [code_get_all_circle_as_vector()] for the results as list
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @return List of on circular sequences constructable with a given code.
#'
#' @examples
#' l_graph <- code_get_one_circle_as_vector(c("ACG", "CGA"))
#' l_graph <- code_get_one_circle_as_vector("ACGCGA", 3)
#' l_graph <- code_get_one_circle_as_vector("ACG CGA")
#'
#' @export
code_get_one_circle_as_vector <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_get_one_circle_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Finds all circular sequences constructable in a code.
#'
#' Prepares a List of R path string vector. Extracts all circular paths of the Graph G(X).
#' If the graph shows no cycle the list will be empty. Otherwise it returns a list object containing vectors with all
#' circular paths.\cr
#' \emph{2007 E. FIMMEL, C. J. MICHEL, AND L. STRÜNGMANN. N-nucleotide circular codes in graph theory}
#'
#' @seealso [code_factor_circles(code)] for code, [code_get_one_circle_as_vector()] for one result as vector
#'
#' @return List of lists of all circular sequences constructable with a given code.
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' l_graph_list <- code_get_all_circle_as_vector(c("ACG", "CGA"))
#' l_graph_list <- code_get_all_circle_as_vector("ACGCGA", tuple_length=3)
#' l_graph_list <- code_get_all_circle_as_vector("ACG CGA")
#'
#' @export
code_get_all_circle_as_vector <- function(code, tuple_length = -1L) {
    .Call('_GCATR_code_get_all_circle_as_vector', PACKAGE = 'GCATR', code, tuple_length)
}

#' Returns all DNA bases
#'
#' @return {"T", "C", "A", "G"}
#' @export 
get_dna_bases <- function() {
    .Call('_GCATR_get_dna_bases', PACKAGE = 'GCATR')
}

#' Returns all DNA bases
#'
#' @return {"U", "C", "A", "G"}
#' @export
get_rna_bases <- function() {
    .Call('_GCATR_get_rna_bases', PACKAGE = 'GCATR')
}

#' Analysis a sequence based on a generic code.
#'
#' Finds all appearance of a code ion a sequence. Finds the longest connected matches of words of the code in the sequence.
#' The function also calculates the matching bases of the found words in the sequence.
#'
#' @return Returns a List with all analysing results. The list contains following:\cr
#' \emph{words} all found words of the code in the sequence in the correct order.\cr
#' \emph{idx_list} the first-letter index of all found words of the code in the sequence in the correct order.\cr
#' \emph{rest} all parts of the sequence which are not matching the code.\cr
#' \emph{parts} the sequence separated in matching and non matching parts. Odd indexes are matching, even indexes are not matching.\cr
#' \emph{longest_match} the longest connected matching sequence.\cr
#' \emph{total_match_in_percent} the percentage of the matching parts.
#'
#' @param code is either a string vector or a string. it can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#'
#' @examples
#' seq <- "ACGTCGCGACGTACGACGTCGTACTCGATGCAAGATC"
#' res <- find_amd_analysis_code_in_sequence(seq, c("ACG", "TCG"))
#' res <- find_amd_analysis_code_in_sequence(seq, "ACGCG", tuple_length=3)
#' res <- find_amd_analysis_code_in_sequence(seq, "ACG TCG")
#'
#' @export
find_amd_analysis_code_in_sequence <- function(seq, code, tuple_length = -1L) {
    .Call('_GCATR_find_amd_analysis_code_in_sequence', PACKAGE = 'GCATR', seq, code, tuple_length)
}

#' @export
generate_code_by_min_value <- function(letter, tuple_length) {
    .Call('_GCATR_generate_code_by_min_value', PACKAGE = 'GCATR', letter, tuple_length)
}

#' @export
shift_tuples <- function(shifts, code, tuple_length = -1L) {
    .Call('_GCATR_shift_tuples', PACKAGE = 'GCATR', shifts, code, tuple_length)
}

