#' BDA Object
#' 
#' This Object contains a binary dichotomic algorithm (BDA) procedure. Use \link{start_bda} or \link{code_start_bda} to get a BDATools object. \cr 
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' seealso [start_bda] for all rna codons, [code_start_bda] for code, [add_rule] add a BDA,
#'           [run_bda] for executing and run the BDAs, [run_bda_as_matrix] for a matrix result
#'           
#' @name BDATools
#' 
#' @examples
#' bda_obj <- start_bda()
#' add_rule(bda_obj, 1, 2, "C", "G", "A", "U")
#' add_rule(bda_obj, 1, 3, "A", "G", "C", "U")
#' res <- run_bda_as_matrix(bda_obj)
#' 
#' @export BDATools
loadModule(module = "BDATools", TRUE)



#' Start a BDA procedure for all codons
#' 
#' This Function starts a binary dichotomic algorithm (BDA) procedure for all codons (see \link{get_rna_codon_list}).
#' To run \link{run_bda_as_matrix} the BDA procedure has been started by this (\link{start_bda}) function.
#' Each added binary BDA results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_rule}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [code_start_bda()] for code, [add_rule] add a BDA,
#'           [run_bda] for executing and run the BDAs
#'
#' @return Boolean value. True if the procedure has started
#' @examples
#' bda_obj <- start_bda()
#' add_rule(bda_obj, 1, 2, "C", "G", "A", "U")
#' add_rule(bda_obj, 1, 3, "A", "G", "C", "U")
#' res <- run_bda_as_matrix(bda_obj)
#' 
#' @export 
start_bda <- function() {
  return(code_start_bda(get_rna_codon_list()))
}

#' Start a BDA procedure for a code.
#' 
#' Each added binary dichotomic algorithm (BDA) results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_rule}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [start_bda()] for all codons, [add_rule] add a BDA,
#'           [run_bda()] for executing and run the BDAs
#'
#' @param code is either a string vector or a string. It can be a DNA or RNA sequence.
#' @param tuple_length if code is a sequence, length is the tuple length of the code.
#' @return Boolean value. True if the procedure has started
#' @examples
#' bda_obj <- code_start_bda(c("ACG", "CAG")) # or
#' bda_obj <- code_start_bda("ACG CAG")       # or
#' bda_obj <- code_start_bda("ACGCAG", tuple_length=3)
#' add_rule(bda_obj, 1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda(bda_obj)
#' 
#' @export
code_start_bda <- function(code, tuple_length = -55555) {
  vec_code <- code_as_vector(code, tuple_length)
  done_code <- paste0(vec_code, collapse = "")
  tuple_length <- code_block_length(vec_code)
  
  bda_obj <- new(BDATools, done_code, tuple_length)
  return(bda_obj)
}

#' Add a binary dichotomic algorithm (BDA).
#' 
#' Each added binary dichotomic algorithm (BDA) results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_rule}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#' @seealso [start_bda()] for all codons,
#'           [code_start_bda()] for code, [run_bda()] for executing and run the BDAs
#'
#' @param bda_obj BDA object (see \link{BDATools}) 
#' @param i_1 A unsigend Integer from 1 - [WORD LENGTH]
#' @param i_2 A unsigend Integer from 1 - [WORD LENGTH]
#' @param Q_11 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_12 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_21 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @param Q_22 A single character. Has to be one of \{'A', 'C', 'G', 'T', 'U'\}
#' @return Boolean value. True if the rules parameters are correct
#' @examples
#' bda_obj <- code_start_bda(c("ACG", "CAG"))
#' add_rule(bda_obj, 1, 2, "C", "G", "A", "T")
#' res.binary <- run_bda(bda_obj)
#' 
#' @export
add_rule <- function(bda_obj, i_1, i_2, Q_11, Q_12, Q_21, Q_22) {
  return(bda_obj$add_rule(i_1, i_2, Q_11, Q_12, Q_21, Q_22))
}



#' Execute BDA procedure.
#' 
#' This function executes the currently open binary dichotomic algorithm (BDA) procedure. Therefore, you need to start a BDA procedure.
#' You can call \link{code_start_bda} to start a procedure
#' for all codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_rule}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#' 
#' @param bda_obj BDA object (see \link{BDATools}) 
#' 
#' @return A List. A binary representation of the Code.
#' 
#' @examples
#' bda_obj<-code_start_bda(c("ACG", "CAG"))
#' add_rule(bda_obj, 1, 2, "C", "G", "A", "T")
#' add_rule(bda_obj, 1, 3, "A", "G", "C", "T")
#' res.binary <- run_bda(bda_obj)
#'
#' @seealso  [start_bda()] for all codons, [add_rule] add a BDA,
#'           [code_start_bda()] for code
#'
#' @export
run_bda <- function(bda_obj) {
  
  return_val <- bda_obj$run_bda_for_code();
  return_list <- list(bda_obj$get_tuples(), return_val)
  names(return_list) <- c("code", "bda")
  return(return_list);
}


#' Execute BDA procedure (only works for all codons).
#' 
#' This Function executes a binary dichotomic algorithm (BDA) procedure. It only works if the BDA procedure has been started by the \link{start_bda} function.
#' Each added binary BDA results one binary digit for each codon.
#' You can add multiple BDAs for one procedure. To add a rule, you need to start a BDA procedure first.
#' To do so you can either call \link{code_start_bda} or to start a procedure
#' for all RNA codons call \link{start_bda}.
#' To add a BDA simply Call \link{add_rule}. To execute the BDAs call \link{run_bda}.
#' A binary dichotomic algorithm generates a binary representation of a generic code. For more info on BDAs read:\cr
#' \emph{M.Gumbel, E.Fimmel, A.Danielli, L.Struengmann. On Models of the Genetic  Code generated by Binary Dichotomic Algorithms}
#'
#'@param bda_obj BDA object (see \link{BDATools}) 
#'
#' @seealso [seq_start_bda()] for sequence, [add_rule] for all codons, [add_rule] add a BDA,
#'           [run_bda] for executing and run the BDAs
#'
#'
#' @return Binary results as Matrix. For example:\cr "UUU -> 00" "UCU -> 10" "UAU -> 00" "UGU -> 10" \cr "UUC -> 00" "UCC -> 10" "UAC -> 00" "UGC -> 10" \cr  "UUA -> 01" "UCA -> 11" "UAA -> 01" "UGA -> 11" \cr  "UUG -> 01" "UCG -> 11" "UAG -> 01" "UGG -> 11" \cr  "CUU -> 00" "CCU -> 00" "CAU -> 00" "CGU -> 00" \cr  "CUC -> 00" "CCC -> 00" "CAC -> 00" "CGC -> 00" \cr  "CUA -> 01" "CCA -> 01" "CAA -> 01" "CGA -> 01" \cr  "CUG -> 01" "CCG -> 01" "CAG -> 01" "CGG -> 01" \cr  "AUU -> 00" "ACU -> 10" "AAU -> 00" "AGU -> 10" \cr  "AUC -> 00" "ACC -> 10" "AAC -> 00" "AGC -> 10" \cr  "AUA -> 00" "ACA -> 10" "AAA -> 00" "AGA -> 10" \cr  "AUG -> 00" "ACG -> 10" "AAG -> 00" "AGG -> 10" \cr  "GUU -> 11" "GCU -> 11" "GAU -> 11" "GGU -> 11" \cr  "GUC -> 11" "GCC -> 11" "GAC -> 11" "GGC -> 11" \cr  "GUA -> 11" "GCA -> 11" "GAA -> 11" "GGA -> 11" \cr  "GUG -> 11" "GCG -> 11" "GAG -> 11" "GGG -> 11"
#'
#' @examples
#' bda_obj <- start_bda()
#' add_rule(1, 2, "C", "G", "A", "U")
#' add_rule(1, 3, "A", "G", "C", "U")
#' res <- run_bda_as_matrix(bda_obj)
#' 
#' @export 
run_bda_as_matrix <- function(bda_obj) {
  res <- run_bda(bda_obj)
  error_msg = "run_bda_as_matrix only works for the correct codon table restart bda procedure with start_bda"
  rna_list = get_rna_codon_list()

  if(length(res$code) != length(rna_list)) {
    stop(error_msg ) 
  }
  for(i in 1:length(res$code)) {
    if(rna_list[i] != res$code[i]) {
      stop(error_msg ) 
    }
    
    rna_list[i] = paste(res$code[i], res$bda[i], sep=" -> ")
  }
  
  return(factor_rna_codon_table(rna_list))
}